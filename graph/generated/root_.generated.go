// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sqlc-rest-api/graph/models"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		CreateProduct func(childComplexity int, input models.NewProduct) int
		CreateUser    func(childComplexity int, input models.NewUser) int
		DeleteProduct func(childComplexity int, input models.URIID) int
		UpdateProduct func(childComplexity int, input models.UpdateProduct) int
	}

	PageInfo struct {
		EndCursor   func(childComplexity int) int
		HasNextPage func(childComplexity int) int
		StartCursor func(childComplexity int) int
	}

	Product struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Price     func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	ProductEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Products struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	Query struct {
		GetProduct func(childComplexity int, input models.URIID) int
		GetUser    func(childComplexity int, input models.URIID) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Products  func(childComplexity int, input models.UserProducts) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.CreateProduct":
		if e.complexity.Mutation.CreateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_CreateProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProduct(childComplexity, args["input"].(models.NewProduct)), true

	case "Mutation.CreateUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_CreateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(models.NewUser)), true

	case "Mutation.DeleteProduct":
		if e.complexity.Mutation.DeleteProduct == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProduct(childComplexity, args["input"].(models.URIID)), true

	case "Mutation.UpdateProduct":
		if e.complexity.Mutation.UpdateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProduct(childComplexity, args["input"].(models.UpdateProduct)), true

	case "PageInfo.end_cursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.has_next_page":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.start_cursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Product.created_at":
		if e.complexity.Product.CreatedAt == nil {
			break
		}

		return e.complexity.Product.CreatedAt(childComplexity), true

	case "Product.id":
		if e.complexity.Product.ID == nil {
			break
		}

		return e.complexity.Product.ID(childComplexity), true

	case "Product.name":
		if e.complexity.Product.Name == nil {
			break
		}

		return e.complexity.Product.Name(childComplexity), true

	case "Product.price":
		if e.complexity.Product.Price == nil {
			break
		}

		return e.complexity.Product.Price(childComplexity), true

	case "Product.user":
		if e.complexity.Product.User == nil {
			break
		}

		return e.complexity.Product.User(childComplexity), true

	case "Product.user_id":
		if e.complexity.Product.UserID == nil {
			break
		}

		return e.complexity.Product.UserID(childComplexity), true

	case "ProductEdge.cursor":
		if e.complexity.ProductEdge.Cursor == nil {
			break
		}

		return e.complexity.ProductEdge.Cursor(childComplexity), true

	case "ProductEdge.node":
		if e.complexity.ProductEdge.Node == nil {
			break
		}

		return e.complexity.ProductEdge.Node(childComplexity), true

	case "Products.edges":
		if e.complexity.Products.Edges == nil {
			break
		}

		return e.complexity.Products.Edges(childComplexity), true

	case "Products.page_info":
		if e.complexity.Products.PageInfo == nil {
			break
		}

		return e.complexity.Products.PageInfo(childComplexity), true

	case "Query.GetProduct":
		if e.complexity.Query.GetProduct == nil {
			break
		}

		args, err := ec.field_Query_GetProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetProduct(childComplexity, args["input"].(models.URIID)), true

	case "Query.GetUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_GetUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["input"].(models.URIID)), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.products":
		if e.complexity.User.Products == nil {
			break
		}

		args, err := ec.field_User_products_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Products(childComplexity, args["input"].(models.UserProducts)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewProduct,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputUpdateProduct,
		ec.unmarshalInputUriID,
		ec.unmarshalInputUserProducts,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/product.graphqls", Input: `type Product {
    id: ID!
    name: String!
    price: Int!
    user_id: ID!
    created_at: Time!
    user: User!
}

type ProductEdge {
    cursor: String!
    node: Product!
}

type Products {
    edges: [ProductEdge!]!
    page_info: PageInfo!
}

type PageInfo {
    start_cursor: String!
    end_cursor: String!
    has_next_page: Boolean!
}

input NewProduct {
    user_id: ID!
    name: String!
    price: Int!
}

input UpdateProduct {
    id: ID!
    name: String!
    price: Int!
}

extend type Mutation {
    CreateProduct(input: NewProduct!): Product!
    UpdateProduct(input: UpdateProduct!): Product!
    DeleteProduct(input: UriID!): Boolean
}

extend type Query {
    GetProduct(input: UriID!): Product!
}`, BuiltIn: false},
	{Name: "../schemas/user.graphqls", Input: `type User {
    id: ID!
    name: String!
    email: String!
    created_at: Time!
    products(input: UserProducts!): Products 
}

input NewUser {
    name: String!
    email: String!
}

input UriID {
    id: ID!
}

input UserProducts {
    user_id: ID!
    first: Int!
    after: String!
}

type Mutation {
    CreateUser(input: NewUser!): User!
}

type Query {
    GetUser(input: UriID!): User!
}

scalar Time`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
